#!/usr/bin/env ruby

require 'fileutils'
require 'tmpdir'
require 'narray' # gem narray
require 'numru/fftw3' # gem ruby-fftw3
require 'coreaudio' # gem coreaudio
require 'curses'

# frames get dropped here
$video_dir = Dir.mktmpdir
at_exit { FileUtils.rm_r $video_dir }

include Curses

init_screen()
start_color()

class NArray; include Enumerable; end

def color mag, average
  size = mag / average

  if size >= 1
    [COLOR_RED, true]
  elsif size >= 0.9
    COLOR_RED
  elsif size >= 0.8
    [COLOR_YELLOW, true]
  elsif size >= 0.7
    COLOR_YELLOW
  elsif size >= 0.6
    [COLOR_MAGENTA, true]
  elsif size >= 0.5
    COLOR_MAGENTA
  elsif size >= 0.4
    [COLOR_BLUE, true]
  elsif size >= 0.3
    COLOR_BLUE
  elsif size >= 0.2
    [COLOR_CYAN, true]
  elsif size >= 0.1
    COLOR_CYAN
  else
    COLOR_GREEN
  end
end

def fetch_audio(from)
  raise Errno::EINVAL.new("no audio specified") unless from
  raise Errno::ENOENT.new(from) unless File.exist?(from)

  if File.extname(from) == '.raw'
    File.read(from)
  else
    `sox "#{from}" -t raw - 2>/dev/null`.force_encoding("ascii-8bit")
  end
end

# Can read frame data already serialized to disk, because ffmpeg's
# writing PPM to disk is really really slow
def fetch_video(from, frames)
  raise Errno::EINVAL.new("no video specified") unless from
  raise Errno::ENOENT.new(from) unless File.exist?(from)

  if File.extname(from) == '.txt'
    Marshal.load(File.read(from).force_encoding('ascii-8bit'))
  else
    system "ffmpeg", "-i", from, "-f", "image2", "-vframes", frames.to_s, "#{$video_dir}/%05d.ppm", 1 => IO::NULL, 2 => IO::NULL

    (0..frames).map do |n|
      image_path = File.join($video_dir,"%05d.ppm" % (n+1))
      `aview -driver stdout -height 26 "#{image_path}"`.split("\f")[1][1..-1] if File.exist? image_path
    end.compact
  end
end

audio = fetch_audio(ARGV[0])
video = fetch_video(ARGV[1], audio.bytesize/47040)

if ARGV.include? '--cache-video'
  $stdout.puts Marshal.dump(video)
  exit
end

dev = CoreAudio.default_output_device
buf = dev.output_buffer(47040)
buf.start

(0..audio.bytesize/47040).each do |n|
  pos = n * 47040
  sample = audio[pos..pos+47039]

  na = NArray.to_narray(sample, NArray::SINT, 2, sample.bytesize/4)
  na_f = na.to_f

  na_complex = NumRu::FFTW3.fft(na_f,-1)
  average_mag = na_complex[0..1].map {|n| n.magnitude}.inject(0,:+)/2
  sample_mag = na_complex.map {|n| n.magnitude}.inject(0,:+)/na_complex.size

  intensities = []
  (0..12).each do |n|
    pos = 1800 * n
    magnitude = na_complex[pos+2..pos+1801].map {|n| n.magnitude}.inject(0,:+)/1800
    # 0 is reserved, so we have to start from 1
    color, intense = color(magnitude, sample_mag)
    intensities << intense
    init_pair(n+1,COLOR_BLACK,color)
  end

  buf << na

  setpos(0,0)
  image = video[n]
  image.lines.each_slice(2).with_index do |lines, index|
    lines.each_with_index do |l,i|
      setpos(index*2+i,0)
      intensity = intensities[index] ? A_NORMAL : A_BOLD
      attron(color_pair(index+1|intensity)) { addstr(l.chomp) }
    end
  end

  refresh()
end

buf.stop
